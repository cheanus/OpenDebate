from pydantic import BaseModel, Field
from .msg import MsgResponse
from enum import Enum
from .link import LinkType


class ScoreType(str, Enum):
    POSITIVE = "positive"
    NEGATIVE = "negative"


class LogicType(str, Enum):
    OR = "or"
    AND = "and"


class CreateOrOpinionRequest(BaseModel):
    content: str = Field(..., description="The content of the opinion", min_length=1)
    creator: str = Field(
        ..., description="ID of the user creating the opinion", min_length=1
    )
    positive_score: float | None = None
    is_llm_score: bool = Field(
        False, description="Whether the score is generated by an LLM"
    )
    debate_id: str = Field(..., description="ID of the debate this opinion belongs to")


class CreateAndOpinionRequest(BaseModel):
    parent_id: str = Field(..., description="ID of the parent opinion", min_length=1)
    son_ids: list[str] = Field(
        ...,
        description="List of IDs of the child opinions",
    )
    link_type: LinkType = Field(
        ..., description="Type of link to create between the parent and child opinions"
    )
    creator: str = Field(
        ..., description="ID of the user creating the opinion", min_length=1
    )
    debate_id: str = Field(..., description="ID of the debate this opinion belongs to")
    loaded_ids: list[str] = Field(
        [], description="List of opinion IDs that are already loaded in the frontend"
    )


class CreateOROpinionResponse(MsgResponse):
    node_id: str = Field(..., description="ID of the created opinion")


class CreateANDOpinionResponse(MsgResponse):
    node_id: str = Field(..., description="ID of the created opinion")
    link_ids: list[str] | None = Field(
        None, description="IDs of the created links if any"
    )
    updated_nodes: dict[str, dict[str, float | None]] | None = Field(
        None, description="IDs of nodes with updated scores and their new scores"
    )


class DeleteOpinionRequest(BaseModel):
    opinion_id: str
    debate_id: str
    loaded_ids: list[str] = Field(
        [], description="List of opinion IDs that are already loaded in the frontend"
    )


class DeleteOpinionResponse(MsgResponse):
    updated_nodes: dict[str, dict[str, float | None]] | None = Field(
        None, description="IDs of nodes with updated scores and their new scores"
    )


class InfoOpinionRequest(BaseModel):
    opinion_id: str
    debate_id: str | None = None


class InfoOpinionResponse(MsgResponse):
    data: dict | None = Field(None, description="Details of the opinion if found")


class QueryOpinionRequest(BaseModel):
    q: str | None = None
    debate_id: str | None = None
    min_score: float | None = None
    max_score: float | None = None
    is_time_accending: bool = Field(
        True, description="Whether to sort the results by time in ascending order"
    )
    max_num: int = Field(
        20, description="Maximum number of opinions to return", le=100, ge=1
    )


class QueryOpinionResponse(MsgResponse):
    data: list[dict] | None = Field(
        None, description="Opinions matching the query parameters"
    )


class HeadOpinionRequest(BaseModel):
    debate_id: str
    is_root: bool = Field(
        ..., description="If True, return leaf opinions; if False, return root opinions"
    )


class HeadOpinionResponse(MsgResponse):
    data: list[str] | None = Field(
        None, description="Leaf/root opinions matching the query parameters"
    )


class PatchOpinionRequest(BaseModel):
    id: str
    content: str | None = None
    score: dict[str, float | None] | None = None
    is_llm_score: bool = Field(
        False, description="Whether the score is generated by an LLM"
    )
    creator: str | None = None
    loaded_ids: list[str] = Field(
        [], description="List of opinion IDs that are already loaded in the frontend"
    )


class PatchOpinionResponse(MsgResponse):
    updated_nodes: dict[str, dict[str, float | None]] | None = Field(
        None, description="IDs of nodes with updated scores and their new scores"
    )
